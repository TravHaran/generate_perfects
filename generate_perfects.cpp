#include <iostream>
#include <vector>
#include <math.h>
#include <chrono>
using namespace std;

/*
AUTHOR: Travis Ratnaharan
DATE: May, 27, 2025
GOAL:
print out all perfect numbers between a range of values 
given by the user
*/

// Naive Approach

// Check if a number is perfect
// Time: O(n)
bool isPerfect(int n){
    int sum = 1;
    int divisor = 2;
    while((n/2) >= divisor){
        if(n%divisor==0)
            sum += divisor;
        divisor++;
    }
    if(n==sum && n!=1)
        return true;
    return false;
}

// Time: O(n^2)
vector<int> naive_algo(int a, int b){
    vector<int> res;
    for(int i = a; i <= b; i++){
        if(isPerfect(i))
            res.push_back(i);
    }

    return res;
}

// Optimized Approach

// Generate all prime numbers up to limit N use Sieve of Eratosthenes
// Time: O(n log(log (n)))
vector<int> sieve(int n){
    vector<int> primes;
    vector<bool> is_prime;
    int limit = sqrt(n);
    for(int i = 0; i <= n+1; i++){
        is_prime.push_back(true);
    }

    for(int j = 2; j < limit; j++){
        if(is_prime[j]){
            primes.push_back(j);
            // mark all multiples of j starting with j^2 up to n,
            // since the prime numbers below j would have already
            // marked everything up to j^2
            for(int a = j*j; a <= n; a += j)
                is_prime[a] = false;
        }
    }

    return primes;
}

// Check if a number is a prime
// Time: O(sqrt(n))
bool isPrime(int n){
    if(n % 2 == 0) return false;
    for(int i = 3; i*i <= n; i += 2){
        if(n % i == 0) return false;
    }
    return true;  
}

// Generate Mersenne Primes
// Time: O(sqrt(n) * log(n))
vector<vector<int>> mersennePrimes(vector<int> primes, int b){
    vector<vector<int>> mersennes; // {{mersenne #, n}}
    for(auto& i : primes){
        // mersenne = ((2^n)-1), as long as n is a prime
        // 2^n is the same as bit shifting to the left by 1; (2^n) = 1 << n
        //int m = (1 << i) - 1;
        int m = pow(2, i)-1;
        if(m <= b and isPrime(m)) // is m is greater than our limit B, there's no point in including it
            mersennes.push_back({m, i});
    }
    return mersennes;
}

// Generate Perfect Numbers
// Doesn't add to Time Complexity
vector<int> generatePerfects(vector<vector<int>> mersennes, int a, int b){
    vector<int> perfects;
    for(auto& entry : mersennes){
        int m = entry[0];
        int n = entry[1];
        // m = (2^n)-1
        // perfect number = ((2^n)-1)*(2^(n-1)) = m*(2^(n-1)) = m * (1<<(n-1))
        //int perf = m * (1<<(n-1));
        int perf = m * pow(2, n-1);
        if(perf >= a && perf <= b)
            perfects.push_back(perf);
    }
    return perfects;
}

/*
Optimized Approach: 

1. generate prime numbers
2. generate mersenne primes
3. generate perfect numbers

Time: 
    O((n log(log (n))) + (sqrt(n) * log(n)))
    This simplifies to: O(n log(log (n)))
*/
vector<int> optimized_algo(int a, int b){
    vector<int> prime_nums = sieve(b);
    vector<vector<int>> mersennes = mersennePrimes(prime_nums, b);
    vector<int> res = generatePerfects(mersennes, a, b);
    return res;
}

int main(){
    int a = 0;
    int b = 100000;

    cout<<"Generating Perfect Numbers Between "<<a <<" and "<<b<<'\n'<<endl;

    vector<int> perfs_naive;
    vector<int> perfs_opt;

    // Naive Algo
    auto start = chrono::high_resolution_clock::now();
    perfs_naive = naive_algo(a, b);
    auto stop = chrono::high_resolution_clock::now();

    // Optimized Algo
    auto start_opt = chrono::high_resolution_clock::now();
    perfs_opt = optimized_algo(a, b);
    auto stop_opt = chrono::high_resolution_clock::now();
    

    auto duration = chrono::duration_cast<chrono::milliseconds>(stop-start);
    auto duration_opt = chrono::duration_cast<chrono::milliseconds>(stop_opt-start_opt);

    cout<<"Time taken for naive algo: "<<duration.count()<<" milliseconds"<<endl;
    cout<<"Time taken for optimized algo: "<<duration_opt.count()<<" milliseconds"<<endl;
    cout<<"\nPerfect numbers generated by naive algo:"<<endl;
    for(auto& p : perfs_naive) cout<<p<<endl;
    cout<<"\nPerfect numbers generated by optimized algo:"<<endl;
    for(auto& p : perfs_opt) cout<<p<<endl;
    return 0;
}
